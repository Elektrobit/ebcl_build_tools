import pytest
import sys

from pathlib import Path
from typing import Any

from ebcl.tools import hypervisor
from ebcl.tools.hypervisor import schema_loader
from ebcl.tools.hypervisor.model import HVConfig
from ebcl.tools.hypervisor.model_gen import BaseModel, ConfigError
from ebcl.tools.hypervisor.schema_loader import DisablePycache, Schema, merge_dict

builtin_data = Path(hypervisor.__file__).parent / "data"
test_data = Path(__file__).parent / "data"


class TestMergeDict:

    def test_empty(self) -> None:
        data: dict[str, Any] = {}
        merge_dict(data, {})
        assert data == {}

    def test_simple(self) -> None:
        old = {
            'int1': 1,
            'int2': 2,
            'bool1': True,
            'bool2': False,
            'str1': 'str1',
            'str2': 'str2',
            'none1': None
        }
        data = old.copy()
        merge_dict(data, {})
        assert old == data

        merge_dict(data, {
            'int1': 12,
            'bool1': False,
            'str1': 'newstr1',
            'none2': None
        })
        old['int1'] = 12
        old['bool1'] = False
        old['str1'] = 'newstr1'
        old['none2'] = None
        assert old == data

    def test_invalid_type(self) -> None:
        data = {'a': object()}
        with pytest.raises(ConfigError, match=r"^Unknown type for a \(<class 'object'>\)$"):
            merge_dict(data, {'a': object()})

    def test_mismatching_types(self) -> None:
        data = {'foo': 1}
        with pytest.raises(ConfigError, match=r"^Type for foo do not match \(<class 'int'> != <class 'bool'>\)$"):
            merge_dict(data, {'foo': True})

    def test_list(self) -> None:
        data = {'foo': [1, 2, 3]}
        merge_dict(data, {'foo': [4, 5, 6]})
        assert data == {'foo': [1, 2, 3, 4, 5, 6]}

    def test_dict(self) -> None:
        data = {'foo': {
            'int': 1,
            'str': 'str'
        }}
        merge_dict(data, {'foo': {
            'int': 5,
            'bool': True
        }})
        assert data == {'foo': {
            'int': 5,
            'bool': True,
            'str': 'str'
        }}


def test_disable_pycache() -> None:
    assert not sys.dont_write_bytecode
    with DisablePycache():
        assert sys.dont_write_bytecode
    assert not sys.dont_write_bytecode


class TestSchema:
    def teardown_method(self) -> None:
        # Clear the class_registry after every test
        # TODO: Maybe the class registry has be converted to a non-global variable tied to the schema loader
        BaseModel.class_registry = {}

    def test_builtin(self) -> None:
        schema = Schema(None)
        assert schema.templates == [
            builtin_data / "io.cfg.j2",
            builtin_data / "system.lua",
            builtin_data / "modules.list.j2",
        ]
        schema._root == HVConfig
        assert schema._schema_version == 1

    def test_extension_missing_version(self) -> None:
        with pytest.raises(ConfigError, match=r"^Version missing in extension schema$"):
            Schema(test_data / "extension_missing_version")

    def test_extension_version_mismatch(self) -> None:
        with pytest.raises(
            ConfigError,
            match=r"^Version of extension schema \(0\) does not match base schema version \(1\)$"
        ):
            Schema(test_data / "extension_version_mismatch")

    def test_overwrite_template(self) -> None:
        schema = Schema(test_data / "extension_overwrite_template")
        assert schema.templates == [
            builtin_data / "io.cfg.j2",
            test_data / "extension_overwrite_template" / "system.lua",
            builtin_data / "modules.list.j2",
        ], "system.lua is overwritten in the extension directory"

    def test_extension_model(self) -> None:
        schema = Schema(test_data / "extension_model")
        assert schema._root.__module__ == "ext_model", "The HVConfig class is replaced by the model"

    def test_extension_model_invalid_base(self) -> None:
        with pytest.raises(ConfigError, match="^Class HVConfig is not derived from BaseModel$"):
            Schema(test_data / "extension_model_invalid_base")

    def test_extension_undefined_class(self) -> None:
        """If a class does not exist in the model, it is implicitly created"""
        schema = Schema(test_data / "extension_undefined_class")
        assert schema._root.__name__ == "UndefinedClass"
        assert schema._root.__bases__[0] == BaseModel
        assert schema._root.__module__ == schema_loader.__name__, "An implicit class is generated by the schema_loader"

        root: Any = schema.parse_config({'a_property': 42})
        assert root.a_property == 42

    def test_extension_missing_root(self) -> None:
        with pytest.raises(ConfigError, match=r"^Missing or invalid root property in schema$"):
            Schema(test_data / "extension_missing_root")

    def test_extension_missing_template(self) -> None:
        with pytest.raises(ConfigError, match="^Unable to find template non-existing-file$"):
            Schema(test_data / "extension_missing_template")
